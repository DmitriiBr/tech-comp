# Фронтовый тех-радар

## Описание

Статья - результат цикла встреч, где обсуждались и выбирались технологий для использования в фронтенд приложении. Она содержит набор выводов и рекомендаций по тому или иному аспекту разработки. В конце сопоставляется старый и новый стек, делается вывод, на основе которого можно принять решение о переходе на другие решения.

## Управление состоянием

_Как ни странно, здесь всё очень не просто._
Сравниваются библиотеки по параметрам:

**Config-first** подход к описанию логики работы с состоянием - это подход, когда для реализации большего числа задач достаточно описать статические параметры или прокинуть колбеки в те же самые параметры. Как пример, apiSlice из RTK Query:

```typescript
export const api = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
        baseUrl: 'https://jsonplaceholder.typicode.com/',
    }),
    tagTypes: ['Posts'],
    endpoints: builder => ({
        getPostsByUser: builder.query<Post[], number>({
            query: userId => `posts?userId=${userId}`,
            providesTags: ['Posts'],
        }),
    }),
})
```

Всё, что мы видим на примере, по сути просто описание и минимум логики. То есть, разработчики библиотеки дают определенный объект с заданными параметрами, где каждый параметр отвечает за что-то свое, а пользователь просто задает в эти параметры свои собственные значения, и вся "магия" происходит под капотом библиотеки.
Такой подход является строгим и позволяет сделать только то, что задумано конфигом. Это позволяет писать более стандартизируемый код, но менее гибкий.

**Logic-first** подход - это противоположный подход, когда разработчики библиотеки предоставляют определенный набор "атомарных" сущностей, манипулируя которыми можно описывать логику. Напрример:

```typescript
// state management
const counter = atom(0)
const increment = () => counter.set(counter() + 1)
const decrement = () => counter.set(counter() - 1)

// API example
export const listResource = computed(async () => {
    const response = await wrap(fetch('https://jsonplaceholder.typicode.com/posts'))
    const data: Post[] = await wrap(response.json())

    return data
}, 'listResource').extend(withAsyncData({ initState: [] }))
```

Здесь отсутствует какой-либо конфиг, используются атомарные методы `atom`, `computed`. А остальное - это привычная логика. Получается, что такой подход является более декларативным и более гибким, но теряет в строгости.

1. Размер библиотеки
2. Удобство АПИ
3. Гибкость АПИ
4. Популярность

### Redux Toolkit

Текущее и самое используемое решение для управления состоянием - это **Redux Toolkit**, а вместе с ник и кеш-менеджер **RTK Query**.
И Redux и RTK Query использует config-first подход для создания и организации составных частей логики. Это значит, что для создания слайса (или АПИ слайса) разработчик заполняет заполняет части одного большого конфига, с небольшими вставками логики в некоторые параметры.

### Tanstack Query

### Nanostores, Nanostores query

### Reatom

## Формы

## Валидация

## Стилизация

## Тестирование

## Реализация микрофронтов

# Фронтовый тех-радар

![Tech initial image](./assets/good_tech_comp_1.jpeg)

## Описание

Статья — результат цикла встреч, где обсуждались и выбирались технологии для использования в фронтенд-приложении. Она содержит набор выводов и рекомендаций по тому или иному аспекту разработки. В конце сопоставляется старый и новый стек, делается вывод, на основе которого можно принять решение о переходе на другие решения.

Оригинал сравнений и все примеры кода расположены в репозитории: https://github.com/DmitriiBr/tech-comp

## Управление состоянием

_Как ни странно, здесь всё очень непросто._ Сравниваются библиотеки по параметрам:

**Config-first** подход к описанию логики работы с состоянием — это подход, когда для реализации большего числа задач достаточно описать статические параметры или прокинуть колбеки в те же самые параметры. Как пример, apiSlice из RTK Query:

```typescript
export const api = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
        baseUrl: 'https://jsonplaceholder.typicode.com/',
    }),
    tagTypes: ['Posts'],
    endpoints: builder => ({
        getPostsByUser: builder.query<Post[], number>({
            query: userId => `posts?userId=${userId}`,
            providesTags: ['Posts'],
        }),
    }),
})
```

Всё, что мы видим на примере, по сути просто описание и минимум логики. То есть разработчики библиотеки дают определённый объект с заданными параметрами, где каждый параметр отвечает за что-то своё, а пользователь просто задаёт в эти параметры свои собственные значения, и вся "магия" происходит под капотом библиотеки.  
Такой подход является строгим и позволяет сделать только то, что задумано конфигом. Это позволяет писать более стандартизируемый код, но менее гибкий.

**Logic-first** подход — это противоположный подход, когда разработчики библиотеки предоставляют определённый набор "атомарных" сущностей, манипулируя которыми можно описывать логику. Например:

```typescript
// state management
const counter = atom(0)
const increment = () => counter.set(counter() + 1)
const decrement = () => counter.set(counter() - 1)

// API example
export const listResource = computed(async () => {
    const response = await wrap(fetch('https://jsonplaceholder.typicode.com/posts'))
    const data: Post[] = await wrap(response.json())

    return data
}, 'listResource').extend(withAsyncData({ initState: [] }))
```

Здесь отсутствует какой-либо конфиг, используются атомарные методы `atom`, `computed`. А остальное — это привычная логика. Получается, что такой подход является более декларативным и более гибким, но теряет в строгости.

### Redux Toolkit

Текущее и самое используемое решение для управления состоянием — это **Redux Toolkit**, а вместе с ним и кеш-менеджер **RTK Query**.  
И Redux, и RTK Query используют config-first подход для создания и организации составных частей логики. Это значит, что для создания слайса (или API слайса) разработчик заполняет части одного большого конфига, с небольшими вставками логики в некоторые параметры.

1. Размер библиотеки — 6.84 MB;
2. Удобство API — Очень много бойлерплейта;
3. Гибкость API — **config-first**, поэтому для экзотических кейсов будут экзотические решения;
4. Популярность — Сейчас начинает немного уступать Tanstack Query. _3,700,972 weekly downloads_;
5. Документация — очень много, по RTK она не сильно уступает Tanstack;

Когда стоит брать? Так как это самое популярное решение — то в любой непонятной ситуации.

### Tanstack Query

Второе в индустрии по популярности решение. Однако, в отличие от Redux Toolkit, в себе содержит только кеш-менеджмент. Это значит, что манипулировать будет возможно только данными запросов, и для решения проблем глобального состояния придётся использовать либо стороннюю библиотеку, либо React Context.

Также представляет собой **config-first** подход, но с описанием параметров в хуке, а не с отдельном файле для API.

```typescript
// RTK
export const api = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
        baseUrl: 'https://jsonplaceholder.typicode.com/',
    }),
    tagTypes: ['Posts'],
    endpoints: builder => ({
        getPostsByUser: builder.query<Post[], number>({
            query: userId => `posts?userId=${userId}`,
            providesTags: ['Posts'],
        }),
    }),
})

// Tanstack Query
const {
    data: posts,
    isLoading: postsLoading,
    isError: postsError,
    error: postsErrorObj,
} = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: async () => {
        const { data } = await axios.get(
            `https://jsonplaceholder.typicode.com/posts?userId=${user.id}`,
        )
        return data
    },
    enabled: !!user,
})
```

На примере видно, что теперь конфиг — это параметры хука, а не API слайса.

1. Размер библиотеки — 732 kB;
2. Удобство API — Нужно придумывать свою организацию множества эндпоинтов. Однако API более минималистичное, чем в RTK;
3. Гибкость API — Так как конфиг прокидывается сразу в хук, а не лежит в отдельном файле, гибкости больше, чем у RTK. Но всё равно теряет в ней из-за **config-first** подхода;
4. Популярность — Обгоняет RTK по популярности. _weekly downloads_;
5. Документация — очень много и она очень качественная.

Когда стоит брать? Если приложение представляет собой **классическое SPA**. То есть в нём будет много запросов, а логика будет на сервере и на фронте не требуется реализовывать сложные кейсы по управлению состоянием, так как в Tanstack Query только кеш.

### Nanostores, Nanostores query

Nanostores является изначально стейт-менеджером, а управление кешом идёт от дополнительной библиотеки Nanostores Query.  
Представляет собой **logic-first** подход к управлению состоянием. То есть, как в примере выше, всё описывается декларативно и вне компонента.

```typescript
const $counter = atom<number>(0)

const increment = () => $counter.set($counter.get() + 1)
const decrement = () => $counter.set($counter.get() - 1)

const $isZero = computed($counter, value => value === 0)

const Comp = () => {
    const counter = useStore($counter)
    const isZero = useStore($isZero)

    //..
}
```

1. Размер библиотеки — 47.5 kB + 67 kB;
2. Удобство API — Атомарный подход, описание стейта получается очень лаконичным и понятным. Его можно и нужно выносить вне компонентов;
3. Гибкость API — Нет привязанности к конфигу, поэтому гибкость безгранична. Однако, как общий минус **logic-first**, придётся придумать свои стандарты и свой код-стайл, чтобы держать всё в одном виде;
4. Популярность — Не популярное решение, как и сам подход к вынесению логики из компонентов. _84,014 weekly downloads_;
5. Документация — её очень мало, это самый большой минус.

Когда стоит брать? Отдельно, с использованием nanostores/query — только если есть желание попробовать что-то новое, иногда тратить время на исследования решений. Хорошо подходит для приложений с большим количеством логики (например offline-first), где весь стейт будет вынесен за компоненты. Также хороший вариант для дополнительного стейт-менеджера в связку к Tanstack Query.

### Reatom

Так же как и nanostores пропагандирует **logic-first** подход к управлению состоянием. Однако является более полноценным решением. Например, позволяет управлять не только пользовательским стейтом, но и кешем, формами, предоставляет различные хелперы для базовых сценариев, например для синхронизации URL и стейта или роутинга.

```tsx
// v1000
const counter = atom(0)
const increment = () => counter.set(counter() + 1)
const decrement = () => counter.set(counter() - 1)

const Comp = reactomComponent(() => (
    <div>
        {counter()}
        <button onClick={increment}>+</button>
        <button onClick={decrement}>-</button>
    </div>
))
```

1. Размер библиотеки — 137 kB;
2. Удобство API — Самое удобное среди рассматриваемых, идея с `reatomComponent` — это то, что позволяет сделать **logic-first** решение более стандартизированным. Работа с кешем гораздо удобнее, чем в nanostores;
3. Гибкость API — Можно сделать буквально что угодно, как и в nanostores;
4. Популярность — На удивление, ещё менее популярен чем nanostores. _~3000 weekly downloads_;
5. Документация — Для 3-й версии она достойная, для v1000 пока набирает обороты. Но в разы лучше чем в nanostores.

Когда стоит брать? Решение в себе содержит массу возможностей сделать что угодно очень красивым и лаконичным способом. Решение явно более полное, чем nanostores, идея с `reatomComponent` позволяет лучше представить, как вся логика по работе со стейтом будет вынесена вне компонентов. Поэтому, если сравнивать с **nanostores** в качестве единственного решения для стейта и кеш-менеджмента, тут однозначно побеждает **reatom**. Если только как стейт-менеджер к Tanstack, то смысла мало, так как большая часть функционала будет утеряна.

## Формы

С библиотеками форм выбор не очень большой. Существует 2 хороших и популярных решения:

1. React hook form;
2. Tanstack form;

При сравнении показалось, что единственным отличием является интерфейс взаимодействия с API библиотеки.  
В react-hook-form — подход, основанный по большей части на хуках. А в tanstack-form — на компонентах.

Пример:

```tsx
// react-hook-form
const Input = ({ name }) => {
    const { field, fieldState } = useController({
        name,
    })

    return (
        <TextField
            {...field}
            label="ID"
            fullWidth
            error={fieldState.invalid}
            helperText={fieldState.error?.message}
        />
    )
}

// tanstack form
const Input = () => {
    return (
        <Field name="subType">
            {({ input, meta }) => (
                <TextField
                    {...input}
                    select
                    label="SubType"
                    fullWidth
                    disabled={!values.type}
                    error={meta.touched && !!meta.error}
                    helperText={meta.touched && meta.error}
                >
                    {subTypeOptions.map(opt => (
                        <MenuItem key={opt.value} value={opt.value}>
                            {opt.label}
                        </MenuItem>
                    ))}
                </TextField>
            )}
        </Field>
    )
}
```

Быстрое сравнение разных библиотек форм есть на официальном сайте Tanstack: https://tanstack.com/form/latest/docs/comparison

### React hook form

На данный момент лучшее решение, по нашему мнению. Из минусов только отсутствие поддержки SSR.

1. Удобный интерфейс;
2. Гибкая настройка;
3. Оптимизация;

### Tanstack form

Уступает react-hook-form по удобству и популярности. Единственный плюс — поддержка SSR.

1. Гибкая настройка;
2. Поддержка SSR;

## Валидация

В сравнении участвовали 3 библиотеки:

1. Yup — текущее решение;
2. Zod — самое популярное, почти стандарт индустрии;
3. Valibot — самая минималистичная библиотека валидации;

### Yup

В новый проект не стоит брать никогда, по причинам:

1. Оптимизация. По сравнению с двумя другими вариантами — медленнее;
2. Поддержка TypeScript. Хуже, так как изначально библиотека разрабатывалась без него;
3. Возможность "мутации" схем валидации. То есть при любом условии в схеме происходит НЕ через описание кейсов схемы, а через мутацию её самой. См. пример ниже.

```typescript
// schema mutation
const a = string()
    .min(10)
    .required()
    .when({
        is: val => val === 'STR',
        then: schema => schema.min(20),
        otherwise: () => number().min(10),
    })

a // -> type ??
```

### Zod

Наш выбор остановился на Zod.  
Стоит брать всегда в новый проект, хотя бы потому, что это самое популярное решение и поддерживается множеством сторонних библиотек из коробки.

**Плюсы:**

1. TypeScript first;
2. Популярность, очень и очень много примеров;
3. Скорость по сравнению с Yup;

Пример такой же `yup` схемы, но на Zod:

```typescript
const a = z.union([z.string(), z.number()]).refine(val => {
    if (typeof val === 'string') {
        if (val === 'STR') {
            return val.length >= 20
        }
        return val.length >= 10
    } else if (typeof val === 'number') {
        return val >= 10
    }
    return false
})

a // -> type is string | number, because of union
```

### Valibot

Минималистичная библиотека, по философии схожая с Zod. Отличается только размером и подходом к составлению схем.

```typescript
// Zod
import z from 'zod'

const a = z.string().max(10)
const b = z.number().min(20)

// Valibot

import { string, pipe, maxLength, minValue } from 'valibot'

const a = pipe(string(), maxLength(10))
const b = pipe(number(), minValue(20))
```

То есть API не "вырастает" из единого источника как в Zod или Yup. Вместо этого библиотека предоставляет атомарные обработчики (они называются action'ами), которые пользователь может по своему желанию соединить и получить схемы для валидации.

Плюсы:

1. TypeScript first;
2. Скорость по сравнению с Yup;

Однако из-за непривычности API и меньшей популярности выбор остановился на Zod.

## Стилизация

Данный раздел является просто информационным, без конкретного выбора.

Есть большое разнообразие библиотек для стилизации, к которым относятся:

1. UI киты;
2. Библиотеки для изоляции стилей;
3. Atomic CSS подходы (Tailwind, atomic css);

Однако, несмотря на разнообразие, все они об одном — стилизация, и какой бы UI кит разработчик ни взял, какой бы подход к стилизации не выбрал, каждый будет представлять из себя либо компоненты с пропсами для кастомизации, либо API для вынесения стилей из компонента. Если наложить на это особенности каждого отдельно взятого проекта, то выбор решения становится почти бессмысленным.  
Поэтому, в цикле тех-радара стилизация рассматривалась с теоретической точки зрения на примере двух подходов: **Runtime** и **Compiletime**.

### Runtime

Стилизация применяется динамически в процессе исполнения страницы браузером. Например, CSS-стили загружаются и применяются непосредственно перед отображением элементов на экране.  
Это позволяет гибко менять стили компонентов в зависимости от условий. Такой подход позволяет воспринимать CSS как часть логики приложения и менять его "на лету" когда захочешь, но увеличивается бандл и замедляет работу приложения.

### Compiletime

Стилизация заранее компилируется в статический код (например `index.css`), который затем используется при рендеринге страницы.  
Такой подход является более оптимальным, ускоряет загрузку интерфейсов и снижает нагрузку на браузер, так как готовое оформление загружается сразу вместе с HTML-кодом.

### Список ссылок на полезные статьи с сравнениями

- Сравнение compile-time и runtime подходов  
  https://dev.to/hamed-fatehi/css-in-js-comparing-compile-time-and-runtime-approaches-51bn

- Сравнение лучших `zero-runtime CSS-in-JS` библиотек  
  https://blog.logrocket.com/comparing-top-zero-runtime-css-js-libraries/

- CSS vs. CSS-in-JS сравнение производительности  
  https://pustelto.com/blog/css-vs-css-in-js-perf/

## Тестирование

В рамках темы тестирования рассматривались библиотеки:

1. Unit тестирование  
   1.1. Jest  
   1.2. Vitest

2. E2E тестирование  
   2.1. Cypress  
   2.2. Playwright

### Unit тестирование

Тут всё довольно просто:

1. Vitest быстрее;
2. Vitest новее;
3. Vitest достаточно популярен, чтобы поддерживать нужные плагины и дополнения;

В остальном, Vitest обратно совместим с Jest с точки зрения API:

```typescript
// Jest and Vitest are the same
describe('test', () => {
    it('Should be correct', () => {
        expect(true).toBe(true)
    })
})
```

Вывод: если есть возможность выбирать, то можно и нужно брать Vitest как решение для Unit тестирования.  
Несколько статей с подробным сравнением:

- Vitest vs Jest | Better Stack Community  
  https://betterstack.com/community/guides/scaling-nodejs/vitest-vs-jest/

- Vitest: Переход на Vitest с Jest - Semaphore CI  
  https://semaphore.io/blog/vitest

- Почему Vite может быть лучше для ваших JavaScript проектов (Divotion)  
  https://www.divotion.com/blog/why-vitest-might-be-better-than-jest-for-your-javascript-projects

- Vitest vs Jest - (Очень наглядное сравнение с точки зрения фич)  
  https://www.speakeasy.com/blog/vitest-vs-jest

### E2E тестирование

Тут немного сложнее. Сравнивались два решения: **Cypress** и **Playwright**. Они оба обладают похожим функционалом, UI режим, Headless (без UI) режим, но, как обычно, есть решающие нюансы, которые в конечном итоге влияют на выбор.

1. Playwright умеет в параллельный запуск (без подписки), в отличие от Cypress. А для долгих E2E это довольно важно;
2. У Playwright API (см. ниже примеры) очень похоже на Jest/Vitest. У Cypress API слишком "нестандартное";
3. У Cypress даже при первичном рассмотрении прослеживается разграничение на платный/бесплатный вариант использования;
4. Playwright поддерживает все браузеры, Cypress только Chromium и Firefox;

Учитывая всё это, выбор остановился на **Playwright**.

**Примеры API:**

```typescript
// Cypress
describe('template spec', () => {
    it('Should show loader, and then remove it after response is ready ', () => {
        cy.contains('Posts List').should('exist')
        cy.get('[role="progressbar"]').should('exist')

        // Request is ready here
        cy.get('[role="progressbar"]').should('not.exist')
    })
})

// Playwright
test('Should show loader, and then remove it after response is ready', async ({ page }) => {
    await page.goto('http://localhost:5173')

    await expect(page.getByRole('progressbar')).toBeInViewport()
    await page.getByRole('progressbar').waitFor({ state: 'hidden' })
    await expect(page.getByRole('progressbar')).not.toBeInViewport()
})
```

Полезные статьи, по аналогии с Jest/Vitest:

- Playwright vs Cypress: Ключевые отличия (LambdaTest)  
  https://www.lambdatest.com/blog/cypress-vs-playwright/

- Cypress vs Playwright - Общее сравнение на 2025 (BugBug.io)  
  https://bugbug.io/blog/test-automation-tools/cypress-vs-playwright/

- Playwright vs Cypress: Основные отличия на 2025 (Katalon)  
  https://katalon.com/resources-center/blog/playwright-vs-cypress

- Playwright vs. Cypress - сравнение E2E фреймворков (Gorzelinski)  
  https://gorzelinski.com/blog/playwright-vs-cypress-comparison-of-e2e-testing-frameworks/

## Реализация микрофронтов

_Примеры кода можно найти по ссылке:_ https://github.com/DmitriiBr/tech-comp/tree/main/microfrontends

При сравнении способов реализации микрофронтов сравнивались подходы:

1. SystemJS
2. importmaps
3. native-federation
4. single-spa
5. module-federation

### Кейс, выбранный для примера

1. Хост — Vite
2. Дочерние приложения на Vite и Webpack
3. У Webpack отличается версия React + ReactDOM

Vite application:

```tsx
const App = () => {
    return <h1>Module from Vite</h1>
}

export default App
```

Webpack application:

```tsx
import { useEffect } from 'react'

const App = () => {
    useEffect(() => {
        console.log('Message from webpack!')
    }, [])

    return <h1>Module from Webpack</h1>
}

export default App
```

### Разделение

#### Подгрузка модулей

Возможно подгружать любой js код в своё приложение.

1. SystemJS
2. importmaps

#### Оркестрация микрофронтов на уровне сборщика

Возможно подгружать любой js код в своё приложение.  
Поверх подгрузки есть возможность оркестрировать (регистрировать) приложения.

1. native-federation
2. single-spa
3. module-federation

### Native federation (FAIL)

1. Должен работать на ES модулях
2. Оркестрация с помощью конфига при сборке
3. Должен быть framework-agnostic

❌- Собрать приложение  
❌- Загрузить Vite  
❌- Загрузить Webpack

#### Минусы

1. Очень много конфигов
2. Очень старые примеры
3. Актуальная либра развивается в основном по экосистеме Angular
4. Документации практически нет

### SystemJS

1. Подгрузка кода
2. Полифил для `importmaps`
3. Полифил для `import('...')`

☑️ - Собрать приложение  
☑️ - Загрузить Vite  
☑️ - Загрузить Webpack

#### Плюсы

1. Минималистичность
2. Кроссбраузерность
3. Очень гибок в использовании, так как по сути является подгрузчиком модулей

#### Минусы

1. Нет инфраструктуры вокруг
2. Мало документации
3. Официальные примеры 6-летней давности

### Import Maps

Маппинг адресов на нативные ES импорты.

☑️ - Собрать приложение  
☑️ - Загрузить Vite  
❌- Загрузить Webpack

#### Плюсы

1. Нативно в браузере, никаких зависимостей

#### Минусы

1. Не кроссбраузерно
2. Проблемы с зоопарком технологий становятся ещё сложнее
3. Прокидывание пропсов становится более сложным

### Single SPA

1. Оркестрация
2. Зоопарк технологий
3. Можно использовать в комбинации с import-maps и systemjs

☑️ - Собрать приложение  
☑️ - Загрузить Vite  
☑️ - Загрузить Webpack

#### Плюсы

1. Удобная оркестрация микрофронтов
2. Есть конфиг в экспортируемом модуле и в сборщике, а то, что в коде — не важно. Позволяет использовать много технологий
3. Есть очень много документации и примеров
4. Хороший вариант, если идёт переход с легаси кода на микрофронты
5. Регистрация приложений происходит после компиляции, то при желании её легче сделать динамической.

#### Минусы

1. Несколько точек, за которыми нужно следить
2. Так себе с шарингом зависимостей
3. Могут быть подводные камни в пробрасывании пропсов

### Module Federation

1. Оркестрация
2. Прост в использовании
3. Является очень популярным решением

☑️ - Собрать приложение  
☑️ - Загрузить Vite  
☑️ - Загрузить Webpack

#### Плюсы

1. Самый простой вариант из всех. Буквально скопировал и всё работает
2. Популярность и активное комьюнити
3. Очень много примеров
4. Удобная оркестрация микрофронтов
5. Множественный exposes

#### Минусы

1. Так себе с шарингом зависимостей
2. Сложно с зоопарком технологий
3. Слабая документация

### Итог

Самым удобным решением оказался **module-federation**, из-за лёгкости конфигурации и большого количества примеров.  
Если проект только начинает разрабатываться и не имеет большого количества легаси кода, то не имеет смысла рассматривать что-либо, кроме **module-federation**.

Однако, если есть большой монолит, содержащий большое количество легаси кода, который требуется распилить на монолит, то только в этом случае можно попробовать посмотреть в сторону Single SPA, так как в нём проще подружить разные технологии между собой.

## Результаты тех-радара

![Tech comp results image](./assets/tech-comp-result.png)

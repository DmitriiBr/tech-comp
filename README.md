# Фронтовый тех-радар

## Описание

Статья - результат цикла встреч, где обсуждались и выбирались технологий для использования в фронтенд приложении. Она содержит набор выводов и рекомендаций по тому или иному аспекту разработки. В конце сопоставляется старый и новый стек, делается вывод, на основе которого можно принять решение о переходе на другие решения.

## Управление состоянием

_Как ни странно, здесь всё очень не просто._
Сравниваются библиотеки по параметрам:

**Config-first** подход к описанию логики работы с состоянием - это подход, когда для реализации большего числа задач достаточно описать статические параметры или прокинуть колбеки в те же самые параметры. Как пример, apiSlice из RTK Query:

```typescript
export const api = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
        baseUrl: 'https://jsonplaceholder.typicode.com/',
    }),
    tagTypes: ['Posts'],
    endpoints: builder => ({
        getPostsByUser: builder.query<Post[], number>({
            query: userId => `posts?userId=${userId}`,
            providesTags: ['Posts'],
        }),
    }),
})
```

Всё, что мы видим на примере, по сути просто описание и минимум логики. То есть, разработчики библиотеки дают определенный объект с заданными параметрами, где каждый параметр отвечает за что-то свое, а пользователь просто задает в эти параметры свои собственные значения, и вся "магия" происходит под капотом библиотеки.
Такой подход является строгим и позволяет сделать только то, что задумано конфигом. Это позволяет писать более стандартизируемый код, но менее гибкий.

**Logic-first** подход - это противоположный подход, когда разработчики библиотеки предоставляют определенный набор "атомарных" сущностей, манипулируя которыми можно описывать логику. Напрример:

```typescript
// state management
const counter = atom(0)
const increment = () => counter.set(counter() + 1)
const decrement = () => counter.set(counter() - 1)

// API example
export const listResource = computed(async () => {
    const response = await wrap(fetch('https://jsonplaceholder.typicode.com/posts'))
    const data: Post[] = await wrap(response.json())

    return data
}, 'listResource').extend(withAsyncData({ initState: [] }))
```

Здесь отсутствует какой-либо конфиг, используются атомарные методы `atom`, `computed`. А остальное - это привычная логика. Получается, что такой подход является более декларативным и более гибким, но теряет в строгости.

1. Размер библиотеки;
2. Удобство АПИ;
3. Гибкость АПИ:
4. Популярность:
5. Документация;

### Redux Toolkit

Текущее и самое используемое решение для управления состоянием - это **Redux Toolkit**, а вместе с ник и кеш-менеджер **RTK Query**.
И Redux и RTK Query использует config-first подход для создания и организации составных частей логики. Это значит, что для создания слайса (или АПИ слайса) разработчик заполняет заполняет части одного большого конфига, с небольшими вставками логики в некоторые параметры.

1. Размер библиотеки - 6.84 MB;
2. Удобство АПИ - Очень много бойлерплейта;
3. Гибкость АПИ - **config-first**, поэтому для экзотических кейсов, буду экзотеческие решения;
4. Популярность - Сейчас начинает немного уступать Tanstack Query. _3,700,972 weekly downloads_;
5. Документация - очень много, по RTK она не сильно уступает Tanstack;

Когда стоит брать? Так как это самое популярное решение, то в любой непонятной ситуации.

### Tanstack Query

Второе в индустрии по популярности решение. Однако, в отличие от Redux Toolkit в себе содержит только кеш-менеджмент. Это значит, что манипулировать будет возможно только данными запросов и для решения проблем глобального состояния придется использовать либо стороннюю библиотеку, либо React Context.

Так же представляет собой **config-first** подход, но с описанием параметров в хуке, а не с отдельном файле для АПИ.

```typescript
// RTK
export const api = createApi({
    reducerPath: 'api',
    baseQuery: fetchBaseQuery({
        baseUrl: 'https://jsonplaceholder.typicode.com/',
    }),
    tagTypes: ['Posts'],
    endpoints: builder => ({
        getPostsByUser: builder.query<Post[], number>({
            query: userId => `posts?userId=${userId}`,
            providesTags: ['Posts'],
        }),
    }),
})

// Tanstack Query
const {
    data: posts,
    isLoading: postsLoading,
    isError: postsError,
    error: postsErrorObj,
} = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => {
        const { data } = await axios.get(
            `https://jsonplaceholder.typicode.com/posts?userId=${user.id}`,
        )
        return data
    },
    enabled: !!user,
})
```

На примере видно, что теперь конфиг - это параметры хука, а не АПИ слайса.

1. Размер библиотеки - 732 kB;
2. Удобство АПИ - Нужно придумывать свою организация множества эндпоинтов. Однако АПИ более минималистичное, чем в RTK;
3. Гибкость АПИ - Так как конфиг прокидывается сразу в хук, а не лежит в отдельном файле, гибкости больше, чем у RTK. Но всё равно, теряет в ней из-за **config-first** подхода;
4. Популярность - Обгоняет RTK по популярности. _ weekly downloads_;
5. Документация - очень много и она очень качественная.

Когда стоит брать? Если приложение представляет собой **классическое SPA**. То есть, в нем будет много запросов, а логика будет на сервере и на фронте не требуется реализовывать сложные кейсы по управлению состоянием, тк в Tanstack Query только кеш.

### Nanostores, Nanostores query

Nanostores является изначально стейт-менеджером, а управление кешом идет от дополнительной библиотеки Nanostores Query.
Представляет собой **logic-first** подход к управлению состоянием. То есть, как в примере выше, всё описыватеся декларативно и вне компонента.

```typescript
const $counter = atom<number>(0)

const increment = () => $counter.set($counter.get() + 1)
const decrement = () => $counter.set($counter.get() - 1)

const $isZero = computed($counter, value => value === 0)

const Comp = () => {
    const counter = useStore($counter)
    const isZero = useStore($isZero)

    //..
}
```

1. Размер библиотеки - 47.5 kB + 67 kB;
2. Удобство АПИ - Атомарный подход, описание стейта получается очень лакончиным и понятным. Его можноь и нужно выносить вне компонентов;
3. Гибкость АПИ - Нет привязанности к конфигу, поэтому гибкость безгранична. Однако, как общий минус **logic-first**, придется придумать свои стандарты и свой код-стайл, чтобы держать всё в одинковом виде;
4. Популярность - Не популярное решение, как и сам подход к вынесению логики из компонентов _84,014 weekly downloads_;
5. Документация - ее очень мало, это самый большой минус

Когда стоит брать? Отдельно, с использованием nanostores/query только если есть желание попробовать что-то новое, иногда тратить время на исследования решений. Хорошо подходит для приложений с большим количеством логики (например offline-first), где весь стейт будет вынесен за компоненты. Так же, хороший вариант для дополнительного стейт менеджера в связку к Tanstack Query.

### Reatom

Так же как и nanostores пропагандирует **logic-first** подход к управлению состоянием. Однако, яляется более полноценным решением. Например, позволяет управлять не только пользовательским стейтом, но и кешем, формами, предоставляет различные хелперы для базовых сценарием, например для синхронизации URL и стейтс или роутинга.

```tsx
// v1000
const counter = atom(0)
const increment = () => counter.set(counter() + 1)
const decrement = () => counter.set(counter() - 1)

const Cmop = reactomComponent(() => (
    <div>
        {counter()}
        <button onClick={increment}>+</button>
        <button onClick={decrement}>-</button>
    </div>
))
```

1. Размер библиотеки - 137 kB;
2. Удобство АПИ - Самое удобное среди рассматриваемых, идея с `reatomComponent` - то, что позволяет сделать **logic-first** решение более стандартизированным. Работа с кешем гораздо удобнее чем в nanostores;
3. Гибкость АПИ - Можно сделать буквально что-угодно, впрочем как и в nanostores;
4. Популярность - На удивление, еще менее популярен чем nanostores. _~3000 weekly downloads_;
5. Документация - Для 3ей версии она достойная, для v1000 пока набирает обороты. Но в разы лучше чем в nanostores;

Когда стоит брать? Решение в себе содержит массу возможностей сделать что угодно очень красивым и лаконичным способом. Решения явно более полное, чем nanostores, идея с `reatomComponent` позволяет лучше представить, как вся логика по работе со стейтом будет вынесена вне компонентов. Поэтому, если сравнивать с **nanostores** в качестве единственного решения для стейт и кеш менеджмента, то тут однозначно побеждает **reatom**. Если только как стейт-менеджер к Tanstack, то смысла мало, тк большая часть функционала будет утеряна.

## Формы

## Валидация

## Стилизация

## Тестирование

## Реализация микрофронтов
